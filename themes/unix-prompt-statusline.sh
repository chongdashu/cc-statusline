#!/bin/bash
# Generated by cc-statusline (https://www.npmjs.com/package/@chongdashu/cc-statusline)
# Custom Claude Code statusline - Created: 2025-08-24T21:40:33.999Z
# Theme: detailed | Colors: true | Features: directory, git, model, context, usage, session, tokens, burnrate

LOG_FILE="${HOME}/.claude/statusline.log"
CACHE_FILE="${HOME}/.claude/statusline.cache"
CACHE_DURATION=2  # Cache for 2 seconds to reduce flicker
TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')

input=$(cat)

# ---- caching to reduce flicker ----
# Generate a hash of the input to detect actual changes
input_hash=$(echo "$input" | md5sum | cut -d' ' -f1)
CACHE_HASH_FILE="${HOME}/.claude/statusline.cache.hash"

# Check if cache exists and is recent
if [ -f "$CACHE_FILE" ] && [ -f "$CACHE_HASH_FILE" ]; then
  cache_age=$(( $(date +%s) - $(stat -f %m "$CACHE_FILE" 2>/dev/null || stat -c %Y "$CACHE_FILE" 2>/dev/null) ))
  stored_hash=$(cat "$CACHE_HASH_FILE" 2>/dev/null)
  
  # Use cache if: 1) it's recent AND 2) input hasn't changed
  if [ "$cache_age" -lt "$CACHE_DURATION" ] && [ "$input_hash" = "$stored_hash" ]; then
    cat "$CACHE_FILE"
    exit 0
  fi
fi

# ---- logging ----
{
  echo "[$TIMESTAMP] Status line triggered with input:"
  (echo "$input" | jq . 2>/dev/null) || echo "$input"
  echo "---"
} >> "$LOG_FILE" 2>/dev/null

# ---- color helpers (force colors for Claude Code) ----
use_color=1
[ -n "$NO_COLOR" ] && use_color=0

C() { if [ "$use_color" -eq 1 ]; then printf '\033[%sm' "$1"; fi; }
RST() { if [ "$use_color" -eq 1 ]; then printf '\033[0m'; fi; }

# ---- modern sleek colors ----
dir_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;117m'; fi; }    # sky blue
model_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;147m'; fi; }  # light purple  
version_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;180m'; fi; } # soft yellow
cc_version_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;249m'; fi; } # light gray
style_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;245m'; fi; } # gray
rst() { if [ "$use_color" -eq 1 ]; then printf '\033[0m'; fi; }

# ---- time helpers ----
to_epoch() {
  ts="$1"
  if command -v gdate >/dev/null 2>&1; then gdate -d "$ts" +%s 2>/dev/null && return; fi
  date -u -j -f "%Y-%m-%dT%H:%M:%S%z" "${ts/Z/+0000}" +%s 2>/dev/null && return
  python3 - "$ts" <<'PY' 2>/dev/null
import sys, datetime
s=sys.argv[1].replace('Z','+00:00')
print(int(datetime.datetime.fromisoformat(s).timestamp()))
PY
}

fmt_time_hm() {
  epoch="$1"
  if date -r 0 +%s >/dev/null 2>&1; then date -r "$epoch" +"%H:%M"; else date -d "@$epoch" +"%H:%M"; fi
}

progress_bar() {
  pct="${1:-0}"; width="${2:-10}"
  [[ "$pct" =~ ^[0-9]+$ ]] || pct=0; ((pct<0))&&pct=0; ((pct>100))&&pct=100
  filled=$(( pct * width / 100 )); empty=$(( width - filled ))
  printf '%*s' "$filled" '' | tr ' ' '='
  printf '%*s' "$empty" '' | tr ' ' '-'
}

# git utilities
num_or_zero() { v="$1"; [[ "$v" =~ ^[0-9]+$ ]] && echo "$v" || echo 0; }

# ---- basics ----
if command -v jq >/dev/null 2>&1; then
  current_dir=$(echo "$input" | jq -r '.workspace.current_dir // .cwd // "unknown"' 2>/dev/null | sed "s|^$HOME|~|g")
  model_name=$(echo "$input" | jq -r '.model.display_name // "Claude"' 2>/dev/null)
  model_version=$(echo "$input" | jq -r '.model.version // ""' 2>/dev/null)
  session_id=$(echo "$input" | jq -r '.session_id // ""' 2>/dev/null)
  cc_version=$(echo "$input" | jq -r '.version // ""' 2>/dev/null)
  output_style=$(echo "$input" | jq -r '.output_style.name // ""' 2>/dev/null)
else
  current_dir="unknown"
  model_name="Claude"; model_version=""
  session_id=""
  cc_version=""
  output_style=""
fi

# ---- git colors ----
git_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;150m'; fi; }  # soft green
rst() { if [ "$use_color" -eq 1 ]; then printf '\033[0m'; fi; }

# ---- git ----
git_branch=""
if git rev-parse --git-dir >/dev/null 2>&1; then
  git_branch=$(git branch --show-current 2>/dev/null || git rev-parse --short HEAD 2>/dev/null)
fi

# ---- context window calculation ----
context_pct=""
context_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;246m'; fi; }  # light gray default

# Determine max context based on model
get_max_context() {
  local model_name="$1"
  case "$model_name" in
    *"Opus 4"*|*"opus 4"*|*"Opus"*|*"opus"*)
      echo "200000"  # 200K for all Opus versions
      ;;
    *"Sonnet 4"*|*"sonnet 4"*|*"Sonnet 3.5"*|*"sonnet 3.5"*|*"Sonnet"*|*"sonnet"*)
      echo "200000"  # 200K for Sonnet 3.5+ and 4.x
      ;;
    *"Haiku 3.5"*|*"haiku 3.5"*|*"Haiku 4"*|*"haiku 4"*|*"Haiku"*|*"haiku"*)
      echo "200000"  # 200K for modern Haiku
      ;;
    *"Claude 3 Haiku"*|*"claude 3 haiku"*)
      echo "100000"  # 100K for original Claude 3 Haiku
      ;;
    *)
      echo "200000"  # Default to 200K
      ;;
  esac
}

if [ -n "$session_id" ] && command -v jq >/dev/null 2>&1; then
  MAX_CONTEXT=$(get_max_context "$model_name")
  
  # Convert current dir to session file path
  project_dir=$(echo "$current_dir" | sed "s|~|$HOME|g" | sed 's|/|-|g' | sed 's|^-||')
  session_file="$HOME/.claude/projects/-${project_dir}/${session_id}.jsonl"
  
  if [ -f "$session_file" ]; then
    # Get the latest input token count from the session file
    latest_tokens=$(tail -20 "$session_file" | jq -r 'select(.message.usage) | .message.usage | ((.input_tokens // 0) + (.cache_read_input_tokens // 0))' 2>/dev/null | tail -1)
    
    if [ -n "$latest_tokens" ] && [ "$latest_tokens" -gt 0 ]; then
      context_used_pct=$(( latest_tokens * 100 / MAX_CONTEXT ))
      context_remaining_pct=$(( 100 - context_used_pct ))
      
      # Set muted colors based on remaining percentage
      if [ "$context_remaining_pct" -le 20 ]; then
        context_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;244m'; fi; }  # medium gray (low)
      elif [ "$context_remaining_pct" -le 40 ]; then
        context_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;245m'; fi; }  # slightly lighter gray
      else
        context_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;242m'; fi; }  # darker gray (plenty)
      fi
      
      context_pct="${context_remaining_pct}%"
    fi
  fi
fi

# ---- usage colors ----
usage_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;245m'; fi; }  # medium gray
cost_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;243m'; fi; }   # darker gray
burn_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;240m'; fi; }   # dark gray
session_color() { 
  rem_pct=$(( 100 - session_pct ))
  if   (( rem_pct <= 10 )); then SCLR='38;5;245'  # medium gray (urgent)
  elif (( rem_pct <= 25 )); then SCLR='38;5;243'  # darker gray (warning)
  else                          SCLR='38;5;241'; fi  # dark gray (normal)
  if [ "$use_color" -eq 1 ]; then printf '\033[%sm' "$SCLR"; fi
}

# ---- ccusage integration (throttled to reduce load) ----
session_txt=""; session_pct=0; session_bar=""
cost_usd=""; cost_per_hour=""; tpm=""; tot_tokens=""

# Only call ccusage every 10 seconds to reduce system load
CCUSAGE_CACHE_FILE="${HOME}/.claude/ccusage.cache"
CCUSAGE_CACHE_DURATION=10  # Update ccusage data only every 10 seconds

ccusage_needs_update=1
if [ -f "$CCUSAGE_CACHE_FILE" ]; then
  ccusage_cache_age=$(( $(date +%s) - $(stat -f %m "$CCUSAGE_CACHE_FILE" 2>/dev/null || stat -c %Y "$CCUSAGE_CACHE_FILE" 2>/dev/null) ))
  if [ "$ccusage_cache_age" -lt "$CCUSAGE_CACHE_DURATION" ]; then
    ccusage_needs_update=0
    blocks_output=$(cat "$CCUSAGE_CACHE_FILE")
  fi
fi

if command -v jq >/dev/null 2>&1; then
  if [ "$ccusage_needs_update" -eq 1 ]; then
    blocks_output=$(npx ccusage@latest blocks --json 2>/dev/null || ccusage blocks --json 2>/dev/null)
    if [ -n "$blocks_output" ]; then
      echo "$blocks_output" > "$CCUSAGE_CACHE_FILE"
    fi
  fi
  
  if [ -n "$blocks_output" ]; then
    active_block=$(echo "$blocks_output" | jq -c '.blocks[] | select(.isActive == true)' 2>/dev/null | head -n1)
    if [ -n "$active_block" ]; then
      cost_usd=$(echo "$active_block" | jq -r '.costUSD // empty')
      cost_per_hour=$(echo "$active_block" | jq -r '.burnRate.costPerHour // empty')
      tot_tokens=$(echo "$active_block" | jq -r '.totalTokens // empty')
      tpm=$(echo "$active_block" | jq -r '.burnRate.tokensPerMinute // empty')
      
      # Session time calculation
      reset_time_str=$(echo "$active_block" | jq -r '.usageLimitResetTime // .endTime // empty')
      start_time_str=$(echo "$active_block" | jq -r '.startTime // empty')
      
      if [ -n "$reset_time_str" ] && [ -n "$start_time_str" ]; then
        start_sec=$(to_epoch "$start_time_str"); end_sec=$(to_epoch "$reset_time_str"); now_sec=$(date +%s)
        total=$(( end_sec - start_sec )); (( total<1 )) && total=1
        elapsed=$(( now_sec - start_sec )); (( elapsed<0 ))&&elapsed=0; (( elapsed>total ))&&elapsed=$total
        session_pct=$(( elapsed * 100 / total ))
        remaining=$(( end_sec - now_sec )); (( remaining<0 )) && remaining=0
        rh=$(( remaining / 3600 )); rm=$(( (remaining % 3600) / 60 ))
        end_hm=$(fmt_time_hm "$end_sec")
        session_txt="$(printf '%dh %dm until reset at %s (%d%%)' "$rh" "$rm" "$end_hm" "$session_pct")"
        session_bar=$(progress_bar "$session_pct" 10)
      fi
    fi
  fi
fi

# ---- log extracted data ----
{
  echo "[$TIMESTAMP] Extracted: dir=${current_dir:-}, model=${model_name:-}, version=${model_version:-}, git=${git_branch:-}, context=${context_pct:-}, cost=${cost_usd:-}, cost_ph=${cost_per_hour:-}, tokens=${tot_tokens:-}, tpm=${tpm:-}, session_pct=${session_pct:-}"
} >> "$LOG_FILE" 2>/dev/null

# ---- render statusline ----
generate_output() {
  # Line 1: Prompt + Core info (user@host pwd $ | git, model, version, style)
  BASE=$(printf '\033[01;31m%s\033[01;33m@\033[01;36m%s \033[01;33m%s \033[01;35m$ \033[00m' \
    "$(whoami)" "$(hostname -s)" "$(pwd)")
  printf '%s' "$BASE"

  # Add git branch if available
  if [ -n "$git_branch" ]; then
    printf 'ðŸŒ¿ %s%s%s  ' "$(git_color)" "$git_branch" "$(rst)"
  fi

  # Add model info
  printf 'ðŸ¤– %s%s%s' "$(model_color)" "$model_name" "$(rst)"
  if [ -n "$model_version" ] && [ "$model_version" != "null" ]; then
    printf ' %s(%s)%s' "$(version_color)" "$model_version" "$(rst)"
  fi

  # Add Claude Code version if available
  if [ -n "$cc_version" ] && [ "$cc_version" != "null" ]; then
    printf '  ðŸ“Ÿ %sv%s%s' "$(cc_version_color)" "$cc_version" "$(rst)"
  fi

  # Add output style if available
  if [ -n "$output_style" ] && [ "$output_style" != "null" ]; then
    printf '  ðŸŽ¨ %s%s%s' "$(style_color)" "$output_style" "$(rst)"
  fi

  # Line 2: Context, Session, Cost and Usage - all in one line
  line2=""

  # Context info
  if [ -n "$context_pct" ]; then
    context_bar=$(progress_bar "$context_remaining_pct" 10)
    line2="ðŸ§  $(context_color)${context_pct} [${context_bar}]$(rst)"
  else
    line2="ðŸ§  $(context_color)TBD$(rst)"
  fi

  # Session time (more compact)
  if [ -n "$session_txt" ]; then
    # Extract just the hours/minutes part for compact display
    if [[ "$session_txt" =~ ([0-9]+h\ [0-9]+m) ]]; then
      compact_time="${BASH_REMATCH[1]}"
      line2="$line2  âŒ› $(session_color)${compact_time} [${session_bar}]$(rst)"
    else
      line2="$line2  âŒ› $(session_color)${session_txt}$(rst)"
    fi
  fi

  # Cost and usage analytics (on same line)
  if [ -n "$cost_usd" ] && [[ "$cost_usd" =~ ^[0-9.]+$ ]]; then
    if [ -n "$cost_per_hour" ] && [[ "$cost_per_hour" =~ ^[0-9.]+$ ]]; then
      cost_per_hour_formatted=$(printf '%.2f' "$cost_per_hour")
      line2="$line2  ðŸ’° $(cost_color)\$$(printf '%.2f' \"$cost_usd\")$(rst) ($(burn_color)\$${cost_per_hour_formatted}/h$(rst))"
    else
      line2="$line2  ðŸ’° $(cost_color)\$$(printf '%.2f' \"$cost_usd\")$(rst)"
    fi
  fi

  if [ -n "$tot_tokens" ] && [[ "$tot_tokens" =~ ^[0-9]+$ ]]; then
    # Format large numbers with K/M suffix for compactness
    if [ "$tot_tokens" -ge 1000000 ]; then
      tok_display=$(printf '%.1fM' "$(echo "scale=1; $tot_tokens/1000000" | bc)")
    elif [ "$tot_tokens" -ge 1000 ]; then
      tok_display=$(printf '%.0fK' "$(echo "scale=0; $tot_tokens/1000" | bc)")
    else
      tok_display="$tot_tokens"
    fi
    
    if [ -n "$tpm" ] && [[ "$tpm" =~ ^[0-9.]+$ ]]; then
      tpm_formatted=$(printf '%.0f' "$tpm")
      # Format TPM with K suffix if large
      if [ "${tpm_formatted%.*}" -ge 10000 ]; then
        tpm_display=$(printf '%.0fK' "$(echo "scale=0; $tpm_formatted/1000" | bc)")
      else
        tpm_display="$tpm_formatted"
      fi
      line2="$line2  ðŸ“Š $(usage_color)${tok_display} (${tpm_display}tpm)$(rst)"
    else
      line2="$line2  ðŸ“Š $(usage_color)${tok_display}$(rst)"
    fi
  fi

  # Print second line
  if [ -n "$line2" ]; then
    printf '\n%s' "$line2"
  fi
  printf '\n'
}

# Generate output and cache it
output=$(generate_output)
echo "$output"

# Save to cache for future use (to prevent flicker)
echo "$output" > "$CACHE_FILE"
echo "$input_hash" > "$CACHE_HASH_FILE"
